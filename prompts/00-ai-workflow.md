# AI開発フロー - 行動指針

## 最初に確認すべきこと

AIがこのプロジェクトで作業を開始する際は、以下の順序で確認してください:

1. **このファイルを最初に読む** - 開発フローの全体像を把握
2. **`12-ideas.md`を確認** - 議論待ちのアイデアがあるか確認
3. **`11-meeting-notes.md`を確認** - 未反映の議事録があるか確認
4. **設計ドキュメントを確認** - 反映すべき内容があるか確認

## コマンド一覧

開発フローを効率的に進めるためのコマンドが用意されています:

- **`/idea`**: アイデア記録フローに入る
  - 新しいアイデアを記録する際に使用
  - `prompts/12-ideas.md`に`[議論待ち]`で記録

- **`/discuss`**: 議論フローに入る
  - アイデアについて議論を開始する際に使用
  - `[議論待ち]`のアイデアを`[議論中]`→`[議論完了]`に更新

- **`/design`**: 設計フローに入る
  - タスクの設計フェーズを開始する際に使用
  - `14-tasks.md`で設計フェーズが`[未着手]`のタスクを確認
  - 設計ドキュメントに反映し、タスクの設計フェーズを`[完了]`に更新

- **`/implement`**: 実装フローに入る
  - タスクの実装フェーズを開始する際に使用
  - `14-tasks.md`で設計フェーズが`[完了]`で実装フェーズが`[未着手]`のタスクを確認
  - 設計ドキュメントに基づいて実装を開始
  - API実装時は必ずフロントエンドとバックエンドの両方を同時に実装する
  - バックエンドの実装にはTDDを推奨（テストコードを先に作成）

- **`/test`**: テストフローに入る
  - タスクのテストフェーズを開始する際に使用
  - `14-tasks.md`で実装フェーズが`[完了]`でテストフェーズが`[未着手]`のタスクを確認
  - テストを実行し、カバレッジを確認
  - 不足しているテストを特定し、作成支援

- **`/review`**: AIレビューフローに入る
  - タスクのAIレビューフェーズを開始する際に使用
  - `14-tasks.md`でテストフェーズが`[完了]`でAIレビューフェーズが`[未着手]`のタスクを確認
  - 実装コード、テストコードをレビュー
  - コーディング規約の遵守を確認
  - 設計ドキュメントとの整合性を確認
  - 改善点があれば指摘

- **`/task`**: タスク管理フローに入る
  - タスクの切り出し、進捗確認、ステータス更新を行う際に使用
  - `14-tasks.md`を確認し、各フェーズの進捗を管理
  - 実行するタスクを決定し、設計フェーズに進む

- **`/status`**: フローの進捗状況を確認
  - アイデア、議事録、タスクが途中で止まっていないか確認
  - 各フェーズの進捗状況を確認し、問題点を検出
  - 次のアクションを提示

- **`/continue`**: 直前の作業を再開
  - 会話履歴から直前の作業を特定し、その続きから再開
  - 設計、実装、テスト、AIレビューなど、会話中に開始された作業を再開
  - 同じコンテキスト上の会話のみから特定（ファイルやタスクステータスは参照しない）

- **`/policy`**: プロジェクトの運用方針を確認
  - 開発フロー、コーディング規約、ディレクトリ構造、テスト戦略、制約事項を確認
  - カテゴリ選択式で表示
  - `prompts/`ディレクトリ内の該当ドキュメントを参照

- **`/summarize`**: 会話上の流れで行った変更を備考などにまとめる
  - 会話履歴から変更内容を抽出し、構造化された形式でまとめる
  - 変更内容、修正理由、影響範囲などを備考として記録
  - 議事録やタスクの備考欄に自動的に反映

## 開発フロー

以下のフローを必ず順序通りに実行してください:

```
アイデア記録 → 議論 → 議事録記録 → タスク切り出し → 設計 → 実装 → テスト → AIレビュー
```

### ステップ1: アイデア記録

**ファイル**: `12-ideas.md`

- 新しいアイデアや機能要望を記録
- ステータス: `[議論待ち]` で記録
- 日付、内容、提案者、優先度を記載

**AIの役割**: 
- `/idea`コマンド実行時、アイデア記録モードに入ることを明確に示す
- **`date +%Y-%m-%d`コマンドを実行して現在の日付を取得し、その日付を使用してアイデアを記録する**（最新のアイデアの日付を参照しない）
- ユーザーからのアイデアを記録する（ユーザーからの指示に基づく）
- 既存のアイデアを確認し、重複がないかチェック
- アイデアが整理できたら、`/discuss`コマンドで議論フローに進むことを提案

### ステップ2: 議論

**ファイル**: `12-ideas.md` (ステータス更新)

- アイデアについて議論を行う（人間が実施）
- ステータスを `[議論中]` → `[議論完了]` に更新
- 議論の結果（採用/却下）を記録

**AIの役割**:
- `/discuss`コマンド実行時、議論モードに入ることを明確に示す
- `[議論待ち]`のアイデアを確認し、議論対象を特定
- 議論の結果に基づいてステータスを更新（`[議論中]` → `[議論完了]`）
- 議論完了後、次のステップ（議事録記録）に進む準備

### ステップ3: 議事録記録

**ファイル**: `11-meeting-notes.md`

- 議論の結果を議事録として記録
- 元のアイデアへの参照を記載
- 決定事項、実装方針を明確に記録
- ステータス: `[未反映]` で記録

**AIの役割**:
- 議論の内容を議事録として整理
- 元のアイデアへのリンクを記載
- 反映先の設計ドキュメントを特定
- 議事録記録後、タスクに切り出すことを提案

### ステップ3.5: タスク切り出し

**ファイル**: `14-tasks.md`

- 議論の結果として、実装すべきタスクを切り出す
- タスクIDを付与（`TASK-YYYYMMDD-XXX`形式）
- 元の議事録への参照を記載
- 4フェーズ（設計/実装/テスト/AIレビュー）のステータスを`[未着手]`で初期化
- 優先度、期限を設定

**AIの役割**:
- 議事録の内容から実装すべきタスクを特定
- `14-tasks.md`にタスクを記録
- タスクIDを生成
- 4フェーズのステータスを初期化
- 各フェーズの進捗を管理
- `/task`コマンド実行時、実行するタスクを決定（ユーザーとAIで選択）
- 選択したタスクの設計フェーズが`[未着手]`の場合、設計フェーズを`[進行中]`に更新し、設計フローに進む

### ステップ4: 設計

**ファイル**: `14-tasks.md` (タスクの設計フェーズ更新) + 該当する設計ドキュメント

- タスクの設計フェーズを`[進行中]`に更新
- 議事録の内容を設計ドキュメントに反映
- 設計完了後、タスクの設計フェーズを`[完了]`に更新
- 設計完了日を記録

**AIの役割**:
- `/design`コマンド実行時、または`/task`コマンドでタスクを選択した後、設計モードに入ることを明確に示す
- `14-tasks.md`で選択したタスクの設計フェーズを確認
- タスクの設計フェーズが`[未着手]`の場合、`[進行中]`に更新
- タスクに関連する議事録を確認し、反映対象を特定
- 必要な設計書（API、画面、モデル）を`design/`ディレクトリに作成・更新
- 設計書の命名規則に従う:
  - API: `[リソース名]-[アクション].md` (例: `users-list.md`, `users-create.md`)
  - 画面: `[画面名]-screen.md` (例: `user-list-screen.md`)
  - モデル: `[モデル名]-model.md` (例: `user-model.md`)
- 既存のテンプレート（`design/api/template.md`, `design/model/template.md`, `design/screen/template.md`）を活用
- タスクの設計フェーズに設計書へのリンクを記載
- プロジェクト全体の設計ドキュメント（`01-project-overview.md`、`02-architecture.md`など）への反映も必要に応じて実施
- 設計ドキュメントの整合性を保つ
- タスクの設計フェーズを`[完了]`に更新
- 設計完了日を記録

### ステップ5: 実装

**ファイル**: `14-tasks.md` (タスクの実装フェーズ更新) + ソースコード（`frontend/src/`, `backend/src/`など） + テストファイル（`backend/tests/`など）

- タスクの実装フェーズを`[進行中]`に更新
- 設計に基づいて実装を開始
- **バックエンドの実装にはTDD（テスト駆動開発）を推奨**
  - テストコードを先に作成（`07-testing-strategy.md`参照）
  - その後、実装コードを作成してテストが通ることを確認
- コーディング規約に従う（`03-coding-standards.md`参照）
- 既存ロジックを確認し、重複を避ける
- 実装完了後、タスクの実装フェーズを`[完了]`に更新
- 実装完了日を記録

**AIの役割**:
- `/implement`コマンド実行時、または`/task`コマンドでタスクを選択した後、実装モードに入ることを明確に示す
- `14-tasks.md`で設計フェーズが`[完了]`で実装フェーズが`[未着手]`のタスクを確認
- タスクの実装フェーズを`[進行中]`に更新
- 設計ドキュメント（`design/`ディレクトリ内の設計書）を確認
- 設計ドキュメントに基づいて実装
- **バックエンドの実装にはTDDを推奨: テストコードを先に作成し、その後実装コードを作成**
- 既存のコードパターンに従う（`05-code-patterns.md`参照）
- 型定義を適切に使用（`06-type-definitions.md`参照）
- **API実装時は必ずフロントエンドとバックエンドの両方を同時に実装する**
- 実装完了後、タスクの実装フェーズを`[完了]`に更新
- 実装完了日を記録

### ステップ6: テスト

**ファイル**: `14-tasks.md` (タスクのテストフェーズ更新) + テストファイル（`backend/tests/`など）

- タスクのテストフェーズを`[進行中]`に更新
- **テストコードは実装フェーズでTDDにより先に作成されていることを確認**
- テストを実行し、エラーがないことを確認
- テストカバレッジを確認し、不足しているテストを特定（`07-testing-strategy.md`参照）
- 不足しているテストがあれば作成支援
- テスト完了後、タスクのテストフェーズを`[完了]`に更新
- テスト完了日を記録

**AIの役割**:
- `/test`コマンド実行時、または`/task`コマンドでタスクを選択した後、テストモードに入ることを明確に示す
- `14-tasks.md`で実装フェーズが`[完了]`でテストフェーズが`[未着手]`のタスクを確認
- タスクのテストフェーズを`[進行中]`に更新
- テストコードが実装フェーズでTDDにより作成されていることを確認
- テストを実行
- テストカバレッジを確認し、不足しているテストを特定
- 不足しているテストがあれば作成支援
- エラーがあれば修正
- テスト完了後、タスクのテストフェーズを`[完了]`に更新
- テスト完了日を記録

### ステップ7: AIレビュー

**ファイル**: `14-tasks.md` (タスクのAIレビューフェーズ更新)

- タスクのAIレビューフェーズを`[進行中]`に更新
- 実装コード、テストコードをレビュー
- コーディング規約の遵守を確認
- 設計ドキュメントとの整合性を確認
- 改善点があれば指摘
- レビュー完了後、タスクのAIレビューフェーズを`[完了]`に更新
- レビュー完了日を記録

**AIの役割**:
- `/review`コマンド実行時、AIレビューモードに入ることを明確に示す
- `14-tasks.md`でテストフェーズが`[完了]`でAIレビューフェーズが`[未着手]`のタスクを確認
- タスクのAIレビューフェーズを`[進行中]`に更新
- 実装コードをレビュー（コーディング規約、設計との整合性）
  - `15-review-guidelines.md`に定義されたチェック項目に従ってレビューを実施
  - `03-coding-standards.md`、`05-code-patterns.md`、`10-constraints.md`、`08-development-workflow.md`を参照
- テストコードをレビュー（カバレッジ、品質）
  - `15-review-guidelines.md`に定義されたチェック項目に従ってレビューを実施
  - `07-testing-strategy.md`を参照
- 設計ドキュメントとの整合性を確認
  - 設計ドキュメント（`design/`ディレクトリ）、API仕様（`13-api-specifications.md`）、型定義（`06-type-definitions.md`）との整合性を確認
- 改善点があれば指摘（パフォーマンス、可読性、保守性、セキュリティ）
- レビュー完了後、タスクのAIレビューフェーズを`[完了]`に更新
- レビュー完了日を記録

## ステータス管理

### アイデアのステータス（`12-ideas.md`）

- `[議論待ち]`: まだ議論されていない
- `[議論中]`: 現在議論中
- `[議論完了]`: 議論が完了し、議事録に移行済み
- `[却下]`: 議論の結果、却下された

### 議事録のステータス（`11-meeting-notes.md`）

- `[未反映]`: まだ設計に反映されていない
- `[反映済み]`: 設計ドキュメントに反映済み
- `[却下]`: 実装しないことが決定

## 作業開始時のチェックリスト

AIが作業を開始する際は、以下を確認してください:

- [ ] `/status`コマンドでフローの進捗状況を確認
- [ ] `12-ideas.md`に`[議論待ち]`のアイデアがあるか
- [ ] `12-ideas.md`に`[議論中]`で長時間止まっているアイデアがあるか
- [ ] `12-ideas.md`に`[議論完了]`で議事録に移行されていないアイデアがあるか
- [ ] `11-meeting-notes.md`に`[未反映]`の議事録があるか
- [ ] `11-meeting-notes.md`に`[反映済み]`でタスクに切り出されていない議事録があるか
- [ ] `14-tasks.md`にタスク切り出しが必要な議事録があるか
- [ ] `14-tasks.md`で設計フェーズが`[未着手]`のタスクがあるか
- [ ] `14-tasks.md`で設計フェーズが`[進行中]`で長時間止まっているタスクがあるか
- [ ] `14-tasks.md`で実装フェーズが`[未着手]`で設計が完了しているタスクがあるか
- [ ] `14-tasks.md`で実装フェーズが`[進行中]`で長時間止まっているタスクがあるか
- [ ] `14-tasks.md`でテストフェーズが`[未着手]`で実装が完了しているタスクがあるか
- [ ] `14-tasks.md`でテストフェーズが`[進行中]`で長時間止まっているタスクがあるか
- [ ] `14-tasks.md`でAIレビューフェーズが`[未着手]`でテストが完了しているタスクがあるか
- [ ] `14-tasks.md`でAIレビューフェーズが`[進行中]`で長時間止まっているタスクがあるか
- [ ] 設計ドキュメントに反映すべき内容があるか
- [ ] 実装すべき機能が設計に記載されているか
- [ ] テストが必要な実装があるか

## 優先順位

作業の優先順位は以下の通りです:

1. **最優先**: `14-tasks.md`でAIレビューフェーズが`[未着手]`のタスク（テスト完了済み）
2. **高**: `14-tasks.md`でテストフェーズが`[未着手]`のタスク（実装完了済み）
3. **高**: `14-tasks.md`で実装フェーズが`[未着手]`のタスク（設計完了済み）
4. **高**: `14-tasks.md`で設計フェーズが`[未着手]`のタスク
5. **中**: `11-meeting-notes.md`にタスク切り出しが必要な議事録があるか
6. **中**: `[議論待ち]`のアイデアを確認（ユーザーに確認）
7. **低**: 既存コードのリファクタリング

## フローの例

### 例1: 新機能追加

1. **アイデア記録**: ユーザーが「ダークモード対応」を提案
   - `12-ideas.md`に`[議論待ち]`で記録

2. **議論**: チームで議論し、実装を決定
   - `12-ideas.md`のステータスを`[議論完了]`に更新

3. **議事録記録**: 議論の結果を記録
   - `11-meeting-notes.md`に`[未反映]`で記録
   - 元のアイデアへの参照を記載

4. **タスク切り出し**: `/task`コマンドでタスク管理フローに入る
   - 議事録から実装すべきタスクを特定
   - `14-tasks.md`にタスクを記録（タスクID: `TASK-20240126-001`）
   - 4フェーズのステータスを`[未着手]`で初期化

5. **設計**: `/design`コマンドで設計フローに入る
   - `14-tasks.md`で設計フェーズを`[進行中]`に更新
   - `02-architecture.md`のUI/UXセクションに追加（または`01-project-overview.md`の将来の拡張要件セクション）
   - 設計完了後、タスクの設計フェーズを`[完了]`に更新

6. **実装**: `/implement`コマンドで実装フローに入る
   - `14-tasks.md`で実装フェーズを`[進行中]`に更新
   - 設計ドキュメントを確認
   - Vuetifyのテーマ機能を使用して実装
   - API実装時はフロントエンドとバックエンドの両方を同時に実装
   - 実装完了後、タスクの実装フェーズを`[完了]`に更新

7. **テスト**: テストを作成・実行
   - `14-tasks.md`でテストフェーズを`[進行中]`に更新
   - フロントエンドの場合は手動テスト
   - バックエンドの場合は自動テスト
   - テスト完了後、タスクのテストフェーズを`[完了]`に更新

8. **AIレビュー**: コードレビューを実施
   - `14-tasks.md`でAIレビューフェーズを`[進行中]`に更新
   - 実装コード、テストコードをレビュー
   - レビュー完了後、タスクのAIレビューフェーズを`[完了]`に更新

## 注意事項

- **フローをスキップしない**: 必ず順序通りに実行
- **ステータスを適切に更新**: 各ステップでステータスを更新
- **設計を先に反映**: 実装前に必ず設計に反映
- **テストを忘れない**: バックエンドの実装には必ずテストを作成
- **進捗を定期的に確認**: `/status`コマンドでフローの進捗状況を定期的に確認し、途中で止まっているものがないかチェック

## ファイル名・コマンド名変更時の確認フロー

ファイル名やコマンド名を変更した場合は、以下の手順で参照の更新を確認します:

### 1. 変更内容の確認

- 変更したファイル名/コマンド名を記録
- 変更前と変更後の名前を明確にする

### 2. 参照箇所の検索

```bash
# ファイル名の検索
grep -r "old-filename.md" prompts/ .cursor/ README.md

# コマンド名の検索
grep -r "/old-command" .cursor/ prompts/ README.md
```

### 3. 参照の更新

検索結果に基づいて、以下のファイルを確認・更新:

- `prompts/`ディレクトリ内の他のファイル
- `.cursor/commands/`ディレクトリ内のファイル
- `README.md`などのドキュメント
- その他の設定ファイル

### 4. 更新確認

- lintを実行してエラーがないか確認
- すべての参照が正しく更新されているか確認

**重要**: ファイル名やコマンド名を変更した場合は、必ずこの確認フローを実行してください。

